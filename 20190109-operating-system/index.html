

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://resource.tinychen.com/logos.png">
  <link rel="icon" href="https://resource.tinychen.com/logos.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="TinyChen">
  <meta name="keywords" content="">
  
    <meta name="description" content="《操作系统》部分重点内容，包括讨论题和部分小七自己整理的概念. 重要知识点。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统部分重点内容">
<meta property="og:url" content="https://tinychen.com/20190109-operating-system/index.html">
<meta property="og:site_name" content="TinyChen&#39;s Studio">
<meta property="og:description" content="《操作系统》部分重点内容，包括讨论题和部分小七自己整理的概念. 重要知识点。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://resource.tinychen.com/20210617164853.jpg">
<meta property="article:published_time" content="2019-01-09T07:00:00.000Z">
<meta property="article:modified_time" content="2019-01-09T07:00:00.000Z">
<meta property="article:author" content="TinyChen">
<meta property="article:tag" content="operatingsystem">
<meta property="article:tag" content="stu">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://resource.tinychen.com/20210617164853.jpg">
  
  
  <title>操作系统部分重点内容 - TinyChen&#39;s Studio</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"tinychen.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":30,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"bash"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"7a96963a1145ac7fde1442d739a11ffd","google":"UA-166769908-1","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="TinyChen's Studio" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TinyChen</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://resource.tinychen.com/20210617164853.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="操作系统部分重点内容"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-01-09 15:00" pubdate>
          January 9, 2019 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="others"
        id="heading-5e2bab0ecb94c4ea40777733195abe1b" role="tab" data-toggle="collapse" href="#collapse-5e2bab0ecb94c4ea40777733195abe1b"
        aria-expanded="true"
      >
        others
        <span class="list-group-count">(30)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-5e2bab0ecb94c4ea40777733195abe1b"
           role="tabpanel" aria-labelledby="heading-5e2bab0ecb94c4ea40777733195abe1b">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/20200907-windows-nt-version/" title="Windows NT对应版本"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Windows NT对应版本</span>
        </a>
      
    
      
      
        <a href="/20200714-ipv4-address-re-match/" title="匹配ipv4地址的正则表达式"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">匹配ipv4地址的正则表达式</span>
        </a>
      
    
      
      
        <a href="/20200512-windows-terminal-wsl2-centos-installation/" title="Windows Terminal + WSL2 + CENTOS 配置Windows命令终端"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Windows Terminal + WSL2 + CENTOS 配置Windows命令终端</span>
        </a>
      
    
      
      
        <a href="/20200331-mstsc-deploy-tls-cert/" title="windows系统RDP远程桌面配置可信证书"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">windows系统RDP远程桌面配置可信证书</span>
        </a>
      
    
      
      
        <a href="/20191212-my-hedt-introduction/" title="为本科毕业设计搭建HEDT平台的硬件选型思路及测试"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">为本科毕业设计搭建HEDT平台的硬件选型思路及测试</span>
        </a>
      
    
      
      
        <a href="/20191203-win10-extreperf-mode/" title="win10开启卓越电源性能计划"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">win10开启卓越电源性能计划</span>
        </a>
      
    
      
      
        <a href="/20190405-delete-3d-objects/" title="删除Windows中的3D对象文件夹"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">删除Windows中的3D对象文件夹</span>
        </a>
      
    
      
      
        <a href="/20190401-mix2-install-google-camera/" title="小米MIX2刷谷歌相机"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">小米MIX2刷谷歌相机</span>
        </a>
      
    
      
      
        <a href="/20190117-compiling/" title="编译原理复习提纲"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">编译原理复习提纲</span>
        </a>
      
    
      
      
        <a href="/20190109-operating-system/" title="操作系统部分重点内容"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">操作系统部分重点内容</span>
        </a>
      
    
      
      
        <a href="/20180824-androidstudio-install/" title="Android Studio配置"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">Android Studio配置</span>
        </a>
      
    
      
      
        <a href="/20180814-raidon-2-ahci/" title="硬盘RaidOn模式无损转换为AHCI模式"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">硬盘RaidOn模式无损转换为AHCI模式</span>
        </a>
      
    
      
      
        <a href="/20180803-jdk-install/" title="JDK安装与环境变量配置"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">JDK安装与环境变量配置</span>
        </a>
      
    
      
      
        <a href="/20180718-tiny-program-02/" title="小程序之app.json"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">小程序之app.json</span>
        </a>
      
    
      
      
        <a href="/20180717-tiny-program-01/" title="小程序之HelloWorld"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">小程序之HelloWorld</span>
        </a>
      
    
      
      
        <a href="/20180630-data-structure/" title="数据结构复习提纲"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据结构复习提纲</span>
        </a>
      
    
      
      
        <a href="/20180318-dou-boot-udisk/" title="双启动U盘"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">双启动U盘</span>
        </a>
      
    
      
      
        <a href="/20180225-disable-keyboard/" title="禁用笔记本内置键盘"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">禁用笔记本内置键盘</span>
        </a>
      
    
      
      
        <a href="/20171227-computer-arch/" title="汕大计组复习提纲2017版"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">汕大计组复习提纲2017版</span>
        </a>
      
    
      
      
        <a href="/20170814-phone-charging-dev/" title="手机充电技术发展史"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">手机充电技术发展史</span>
        </a>
      
    
      
      
        <a href="/categories/others/" class="list-group-item list-group-item-action">
          <span class="category-post">More...</span>
        </a>
        
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统部分重点内容</h1>
            
              <p class="note note-info">
                
                  
                    Last updated on January 9, 2019 pm
                  
                
              </p>
            
            <div class="markdown-body">
              
              <p>《操作系统》部分重点内容，包括讨论题和部分小七自己整理的概念. 重要知识点。</p>
<span id="more"></span>

<hr>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><hr>
<h2 id="1-请你给操作系统下个定义？"><a href="#1-请你给操作系统下个定义？" class="headerlink" title="1. 请你给操作系统下个定义？"></a>1. 请你给操作系统下个定义？</h2><p>一般可把操作系统定义为：管理系统资源. 控制程序执行. 改善人机界面. 提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好运行环境的一种系统软件。</p>
<hr>
<h2 id="2-请叙述操作系统的专业地位和在计算机系统中的地位？"><a href="#2-请叙述操作系统的专业地位和在计算机系统中的地位？" class="headerlink" title="2. 请叙述操作系统的专业地位和在计算机系统中的地位？"></a>2. 请叙述操作系统的专业地位和在计算机系统中的地位？</h2><p><strong>操作系统属于专业基础课</strong></p>
<p><strong>系统软件（操作系统）层是最靠近硬件的一层软件，它一方面直接和硬件交互，在裸机上运行；另一方面和上层的支撑软件和应用软件交互，把它们与计算机硬件隔离开来。</strong></p>
<blockquote>
<p>操作系统是最靠近硬件的一层软件，它把硬件裸机改造成为完善的虚拟机，使得机器功能得到扩展，运行环境得到改善，系统效率得到提高，安全性能得到保障。</p>
</blockquote>
<blockquote>
<p>系统软件（操作系统）层是最靠近硬件的一层软件，它一方面直接和硬件交互，在裸机上运行，把硬件的复杂性封装起来，负责管理和控制机器硬件并对其做首次扩充和改造，主要做好资源的调度与分配. 信息的存取与保护. 并发活动的协调与控制等工作；另一方面和上层的支撑软件和应用软件交互，把它们与计算机硬件隔离开来，为程序员提供方便的编程接口. 有力的功能支撑. 良好的运行环境，使得计算机系统成为完整. 可用和高效的计算平台。</p>
</blockquote>
<hr>
<h2 id="3-操作系统系统的作用是什么？"><a href="#3-操作系统系统的作用是什么？" class="headerlink" title="3. 操作系统系统的作用是什么？"></a>3. 操作系统系统的作用是什么？</h2><p>操作系统在计算机系统中起4个方面的作用。</p>
<ol>
<li>服务用户观点——操作系统作为用户接口和公共服务程序</li>
<li>进程交互观点——操作系统作为进程执行的控制者和协调者</li>
<li>系统实现观点——操作系统作为扩展机或虚拟机</li>
<li>资源管理观点——操作系统作为资源的管理者和控制者</li>
</ol>
<hr>
<h2 id="4-操作系统所管理的资源有那些？支持的界面使用方式有哪些？"><a href="#4-操作系统所管理的资源有那些？支持的界面使用方式有哪些？" class="headerlink" title="4. 操作系统所管理的资源有那些？支持的界面使用方式有哪些？"></a>4. 操作系统所管理的资源有那些？支持的界面使用方式有哪些？</h2><p><strong>在计算机系统中，能分配给用户使用的各种软硬件设施总称为资源。</strong></p>
<p><strong>资源包括两大类：硬件资源和软件资源。</strong>其中，硬件资源有处理器. 存储器. 外部设备等；软件资源则分为程序和数据。</p>
<p><strong>支持的界面使用方式主要有两种：命令行模式（CLI）和图形化界面（GUI）</strong></p>
<hr>
<h2 id="5-什么原因推动我们操作系统的发展？"><a href="#5-什么原因推动我们操作系统的发展？" class="headerlink" title="5. 什么原因推动我们操作系统的发展？"></a>5. 什么原因推动我们操作系统的发展？</h2><p><strong>两个原因：人类日常生产生活的实际需求和硬件设备（尤其是集成电路）的发展。</strong></p>
<hr>
<h2 id="6-何为中断？中断处理过程如何？中断分类？中断服务？中断源？中断优先级？中断屏蔽与开关中断？中断要保存和恢复的内容有哪些？"><a href="#6-何为中断？中断处理过程如何？中断分类？中断服务？中断源？中断优先级？中断屏蔽与开关中断？中断要保存和恢复的内容有哪些？" class="headerlink" title="6. 何为中断？中断处理过程如何？中断分类？中断服务？中断源？中断优先级？中断屏蔽与开关中断？中断要保存和恢复的内容有哪些？"></a>6. 何为中断？中断处理过程如何？中断分类？中断服务？中断源？中断优先级？中断屏蔽与开关中断？中断要保存和恢复的内容有哪些？</h2><h3 id="中断的定义"><a href="#中断的定义" class="headerlink" title="中断的定义"></a>中断的定义</h3><p>中断指在程序执行过程中遇到急需处理的事件时，暂时中止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再返回断点或调度其他程序执行的过程。</p>
<h3 id="中断处理过程如何？"><a href="#中断处理过程如何？" class="headerlink" title="中断处理过程如何？"></a>中断处理过程如何？</h3><p>一般来说，中断/异常的响应需要<strong>顺序做4件事：</strong></p>
<ol>
<li>发现中断源</li>
<li>保护现场</li>
<li>转向中断/异常事件处理程序执行</li>
<li>恢复现场 </li>
</ol>
<h3 id="中断分类？"><a href="#中断分类？" class="headerlink" title="中断分类？"></a>中断分类？</h3><p>由硬件发出或产生的中断称为硬中断，按硬中断事件的来源和实现手段可<strong>将中断划分为外中断和内中断。</strong></p>
<ul>
<li><strong>外中断又称中断或异步中断，</strong>是指来自处理器之外的中断信号；</li>
<li><strong>内中断又称异常或同步中断，</strong>是指来自处理器内部的中断信号；</li>
</ul>
<blockquote>
<p>中断的发生与CPU当前状态无关，即可发生在用户态，又可发生在内核态；<br>异常与CPU是同步的，大部分异常发生在用户态，<strong>内核态唯一发生的异常是“缺页异常”</strong></p>
</blockquote>
<h3 id="中断服务？"><a href="#中断服务？" class="headerlink" title="中断服务？"></a>中断服务？</h3><blockquote>
<p><strong>摘自百度百科：</strong>中断服务程序，处理器处理“急件”，可理解为是一种服务，是通过执行事先编好的某个特定的程序来完成的，这种处理“急件”的程序被称为——中断服务程序。</p>
</blockquote>
<h3 id="中断源？"><a href="#中断源？" class="headerlink" title="中断源？"></a>中断源？</h3><p>中断源指中断信号的来源。</p>
<h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>中断装置所预设的响应顺序称为中断优先级。</p>
<h3 id="中断屏蔽与开关中断？"><a href="#中断屏蔽与开关中断？" class="headerlink" title="中断屏蔽与开关中断？"></a>中断屏蔽与开关中断？</h3><p><strong>中断屏蔽是指禁止CPU响应中断或禁止中断产生。</strong></p>
<ul>
<li>前者指硬件产生中断请求后，CPU暂时不予响应的状态，等待直到中断开放后被屏蔽的中断才能被响应并获得处理。</li>
<li>后者指可引起中断的事件发生时，硬件不允许提出中断请求也不通知处理器，故由于中断被禁止而不可能导致中断。</li>
</ul>
<h3 id="中断要保存和恢复的内容有哪些？"><a href="#中断要保存和恢复的内容有哪些？" class="headerlink" title="中断要保存和恢复的内容有哪些？"></a>中断要保存和恢复的内容有哪些？</h3><p>通用寄存器. 状态寄存器. 程序计数器(PC). 程序状态字(PSW)</p>
<hr>
<h2 id="7-系统调用？"><a href="#7-系统调用？" class="headerlink" title="7. 系统调用？"></a>7. 系统调用？</h2><p><strong>系统调用是一种中介角色，把用户和硬件隔离开来，应用程序只有通过系统调用才能请求系统服务并使用系统资源。</strong></p>
<p>系统调用的作用：一是内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性；二是系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率大大提高。</p>
<blockquote>
<p>可以这样认为：内核的主体是系统调用的集合，可以将内核的服务例程看成特殊的公共子程序。</p>
</blockquote>
<blockquote>
<p>系统调用是应用程序获得操作系统服务的唯一途径。</p>
</blockquote>
<hr>
<h2 id="8-市场上os的分类？"><a href="#8-市场上os的分类？" class="headerlink" title="8. 市场上os的分类？"></a>8. 市场上os的分类？</h2><p>市场上OS的分类依据分类标准的不同可以有许多种分法：</p>
<h3 id="按照使用设备来进行分类的话，大概可以分为三类："><a href="#按照使用设备来进行分类的话，大概可以分为三类：" class="headerlink" title="按照使用设备来进行分类的话，大概可以分为三类："></a>按照使用设备来进行分类的话，大概可以分为三类：</h3><ul>
<li><p>移动端：主要是Android和IOS占主流，也有少数的如WindowsMobile等小众移动操作系统；</p>
</li>
<li><p>桌面端：主要是Windows. MacOS和主流的Linux发行版如Redhat. Ubuntu. CentOS. SUSE等，还有少数的Unix操作系统；</p>
</li>
<li><p>服务器端：主要运行的是Linux和Unix操作系统</p>
</li>
</ul>
<p>其他还有更细致的分类诸如嵌入式系统等。</p>
<h3 id="按照功能-特点和使用方式，可以把操作系统分为三种基本类型"><a href="#按照功能-特点和使用方式，可以把操作系统分为三种基本类型" class="headerlink" title="按照功能. 特点和使用方式，可以把操作系统分为三种基本类型"></a>按照功能. 特点和使用方式，可以把操作系统分为三种基本类型</h3><h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><ul>
<li><p>批处理操作系统服务于一系列称为批（batch）的作业。</p>
</li>
<li><p>采用批处理方式工作的操作系统称为批处理操作系统。</p>
</li>
<li><p>批处理操作系统是<strong>最先</strong>采用多道程序设计技术的系统，它根据预先设定的调度策略选择若干作业并发地执行，系统资源利用率高，作业吞吐量大。</p>
</li>
<li><p><strong>批处理操作系统的缺点</strong>是作业周转时间延长，不具备交互式计算能力，不利于程序的开发和调试。</p>
</li>
<li><p><strong>批处理操作系统的特征</strong>是批量集中处理. 多道程序运行. 作业脱机工作。</p>
</li>
</ul>
<h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><ul>
<li><p>实质上，分时操作系统是多道程序的一个变种，CPU被若干交互式用户多路复用，不同之处在于每个用户都拥有一台联机终端。</p>
</li>
<li><p><strong>分时操作系统的四大特点为：同时性. 独立性. 及时性. 交互性。</strong></p>
</li>
<li><p><strong>同时性：</strong>即若干终端用户联机使用计算机，分时是指多个用户分享同一台计算机的CPU时间；</p>
</li>
<li><p><strong>独立性：</strong>即终端用户彼此独立，互不干扰，每个终端用户感觉好像独占整台计算机；</p>
</li>
<li><p><strong>及时性：</strong>即终端用户没有大计算量的立即型请求能够在足够短时间内得到响应；</p>
</li>
<li><p><strong>交互性：</strong>即人机交互，联机工作时用户直接控制程序运行，便于程序调试和排错。</p>
</li>
</ul>
<h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><blockquote>
<p>实时操作系统时指外部事件或数据产生时，能够对其予以足够快的速度进行处理，所得结果能够在规定的时间内控制生产过程或对控制对象做出快速响应，并控制所有实时任务协调运行的操作系统。</p>
</blockquote>
<ul>
<li><p>提供<strong>及时响应和高可靠性</strong>是其主要特点。</p>
</li>
<li><p><strong>有三种典型实时系统：过程控制系统. 信息查询系统和事务处理系统。</strong></p>
</li>
</ul>
<p><strong>如果某个操作系统兼具批处理. 分时和实时处理的全部或两种功能，则此操作系统称为通用操作系统。</strong></p>
<hr>
<h2 id="9-单道程序设计和多道的区别？"><a href="#9-单道程序设计和多道的区别？" class="headerlink" title="9. 单道程序设计和多道的区别？"></a>9. 单道程序设计和多道的区别？</h2><p>在早期<strong>单道批处理系统</strong>中，内存中仅有单个作业在运行，CPU和其他硬件设备串行工作，致使系统中仍有许多资源空闲，设备利用率极低。</p>
<p><strong>多道程序设计</strong>是指允许多个作业（程序）同时进入计算机系统的内存并启动交替计算的方法。</p>
<hr>
<h2 id="10-系统调用与函数调用之间的区别？"><a href="#10-系统调用与函数调用之间的区别？" class="headerlink" title="10. 系统调用与函数调用之间的区别？"></a>10. 系统调用与函数调用之间的区别？</h2><p>两者从调用形式到具体实现都存在很大区别：</p>
<h3 id="（1）调用形式和实现方式不同："><a href="#（1）调用形式和实现方式不同：" class="headerlink" title="（1）调用形式和实现方式不同："></a>（1）调用形式和实现方式不同：</h3><ul>
<li><p>函数调用所转向的地址式<strong>固定不变</strong>的，但系统调用中不包含内核服务例程入口地址，仅提供功能号，<strong>按功能号调用</strong>；</p>
</li>
<li><p>函数调用是在<strong>用户态执行</strong>，<strong>只能访问用户栈</strong>；</p>
</li>
<li><p>系统调用需要通过<strong>陷阱机制</strong>，从用户态转换到内核态，<strong>服务例程在内核态执行并访问核心栈</strong>。</p>
</li>
</ul>
<h3 id="（2）被调用代码的位置不同："><a href="#（2）被调用代码的位置不同：" class="headerlink" title="（2）被调用代码的位置不同："></a>（2）被调用代码的位置不同：</h3><ul>
<li><p><strong>函数调用是静态调用</strong>，调用程序和被调用代码处于同一程序内，这是用户级程序</p>
</li>
<li><p><strong>系统调用是动态调用</strong>，系统调用的服务例程位于操作系统中，这是系统级程序</p>
</li>
</ul>
<h3 id="（3）提供方式不同："><a href="#（3）提供方式不同：" class="headerlink" title="（3）提供方式不同："></a>（3）提供方式不同：</h3><ul>
<li><p><strong>函数调用通常由编程语言提供</strong>，不同的语言提供的函数功能的类型和数量<strong>可以不同</strong></p>
</li>
<li><p><strong>系统调用由操作系统提供</strong>，操作系统一般设计好，系统调用的功能. 类型和数量便<strong>固定不变</strong></p>
</li>
</ul>
<hr>
<h2 id="11-操作系统结构分类？"><a href="#11-操作系统结构分类？" class="headerlink" title="11. 操作系统结构分类？"></a>11. 操作系统结构分类？</h2><blockquote>
<p><strong>Linux系统使用的是单体式结构。</strong></p>
</blockquote>
<h3 id="单体式结构"><a href="#单体式结构" class="headerlink" title="单体式结构"></a>单体式结构</h3><p>操作系统单体式结构采用模块组合法，是基于结构化程序设计的一种软件结构设计方法。</p>
<blockquote>
<p><strong>优点是：</strong>结构紧密. 组合方便，对不同环境和用户的不同需求可以组合不同模块来满足，灵活性大；针对某个功能可用最有效的算法和任意调用其他模块中的过程来实现，因此系统效率高。</p>
</blockquote>
<blockquote>
<p>** 缺点是：**模块独立性差，模块之间牵连甚多，形成复杂的调用关系，甚至有循环调用，造成系统结构不清晰，正确性难以保证，可靠性降低，系统的增. 删. 改困难。</p>
</blockquote>
<h3 id="层次式结构"><a href="#层次式结构" class="headerlink" title="层次式结构"></a>层次式结构</h3><p>这种结构把操作系统划分为内核和若干模块（进程），这些模块（进程）按功能的调用次序排列成若干层次，<strong>各层之间只能存在单向依赖或单向调用关系，即低层为高层服务，高层可以调用低层功能，反之则不能。</strong></p>
<h3 id="虚拟机结构"><a href="#虚拟机结构" class="headerlink" title="虚拟机结构"></a>虚拟机结构</h3><p>它基于如下思想：物理计算机资源通过多重化和共享技术可改造成多个虚拟机。<br>这种技术的基本做法是：通过用一类物理设备来模拟另一类物理设备，或通过分时地使用一类物理设备，把一个物理实体改变成若干个逻辑上的对应物。</p>
<h3 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h3><p>操作系统仅将所有应用必需的核心功能放入内核，称为微内核，其他功能都在内核之外，由在用户态运行的服务进程实现，通过微内核所提供的消息传递机制完成进程间消息通信。</p>
<blockquote>
<p><strong>微内核结构的优点</strong>，一是对进程的请求提供一致性接口，不必区分内核级服务和用户级服务，所有服务均借助消息传递机制提供；二是具有较好的可扩充性和易修改性，三是可移植性好；四是对分布式系统提供有力支撑；</p>
</blockquote>
<blockquote>
<p><strong>微内核结构的缺点</strong>是运行效率较低，这是因为进程间必须通过内核的通信机制才能进行通信。</p>
</blockquote>
<hr>
<h2 id="12-自由软件？"><a href="#12-自由软件？" class="headerlink" title="12. 自由软件？"></a>12. 自由软件？</h2><p>自由软件（free software，又称freeware）是指遵循通用公共许可证（General Public License，GPL）规则，保证使用上的自由，获得源程序的自由，可以自行修改的自由，可以复制和推广的自由，也可以<strong>有收费自由</strong>的一种软件。</p>
<blockquote>
<p><strong>注意 ：自由软件不是免费软件，自由软件也有收费的。</strong></p>
</blockquote>
<hr>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><hr>
<h2 id="1-作业生命周期状态？"><a href="#1-作业生命周期状态？" class="headerlink" title="1. 作业生命周期状态？"></a>1. 作业生命周期状态？</h2><ul>
<li>输入状态</li>
<li>后备状态</li>
<li>执行状态</li>
<li>完成状态</li>
</ul>
<hr>
<h2 id="2-何为低级调度？"><a href="#2-何为低级调度？" class="headerlink" title="2. 何为低级调度？"></a>2. 何为低级调度？</h2><p><strong>低级调度又称进程调度/线程调度. 短程调度，</strong>根据某种原则决定就绪队列中的哪个进程/线程获得处理器，并将处理器出让给它使用。</p>
<hr>
<h2 id="3-进程调度方式有哪些？解释这些方式？"><a href="#3-进程调度方式有哪些？解释这些方式？" class="headerlink" title="3. 进程调度方式有哪些？解释这些方式？"></a>3. 进程调度方式有哪些？解释这些方式？</h2><p><strong>低级调度有两类基本调度方式：剥夺式和非剥夺式。</strong></p>
<h3 id="剥夺式"><a href="#剥夺式" class="headerlink" title="剥夺式"></a>剥夺式</h3><p>剥夺式又称为抢先式。当进程/线程正在处理器上运行时，<strong>系统可根据规定的原则剥夺分配给此进程/线程的处理器，</strong>并将其移入就绪队列，选择其他进程/线程运行。</p>
<h3 id="非剥夺式"><a href="#非剥夺式" class="headerlink" title="非剥夺式"></a>非剥夺式</h3><p>非剥夺式又称非抢先式。<strong>一旦某个进程/线程开始运行后便不再让出处理器，</strong>除非此进程/线程运行结束或主动放弃处理器，或因发生某个事件而不能继续执行。</p>
<hr>
<h2 id="4-进程调度队列模型有何作用？"><a href="#4-进程调度队列模型有何作用？" class="headerlink" title="4. 进程调度队列模型有何作用？"></a>4. 进程调度队列模型有何作用？</h2><p>进程队列调度模型负责<strong>处理器的分配</strong>，作用为以下几点：</p>
<ol>
<li><p>将系统中各进程的执行情况和状态特征记录在各进程的PCB表中并将各进程的PCB表排成相应的队列。</p>
</li>
<li><p>通过PCB变化来掌握系统中存在的所有进程的执行情况和状态特征，并在适当的时机从就绪队列中选择出一个进程占据CPU。</p>
</li>
<li><p>当进程调度为剥夺式时且新就绪进程优先级高于当前进程时能取回CPU并分配给新进程。</p>
</li>
</ol>
<hr>
<h2 id="5-何为周转时间？平均周转时间？响应时间？"><a href="#5-何为周转时间？平均周转时间？响应时间？" class="headerlink" title="5. 何为周转时间？平均周转时间？响应时间？"></a>5. 何为周转时间？平均周转时间？响应时间？</h2><h3 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h3><p>批处理用户从向系统提交作业开始到作业完成为止的时间间隔称为作业周转时间。</p>
<h3 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h3><p>所有进程的周转时间之和除以进程数得到的就是平均周转时间。</p>
<h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>从交互式进程提交一个请求（命令）直到获得响应之间的时间间隔称为响应时间。</p>
<hr>
<h2 id="6-进程调度算法的作用是什么？"><a href="#6-进程调度算法的作用是什么？" class="headerlink" title="6. 进程调度算法的作用是什么？"></a>6. 进程调度算法的作用是什么？</h2><p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数. 这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p>
<hr>
<h2 id="7-掌握三种进程调度算法的名字与思想？重点掌握多级反馈队列调度算法。"><a href="#7-掌握三种进程调度算法的名字与思想？重点掌握多级反馈队列调度算法。" class="headerlink" title="7. 掌握三种进程调度算法的名字与思想？重点掌握多级反馈队列调度算法。"></a>7. 掌握三种进程调度算法的名字与思想？重点掌握多级反馈队列调度算法。</h2><h3 id="FCFS-先来先服务算法"><a href="#FCFS-先来先服务算法" class="headerlink" title="FCFS/先来先服务算法"></a>FCFS/先来先服务算法</h3><ul>
<li><strong>非剥夺式调度算法</strong></li>
<li>FCFS按照作业进入系统后备作业队列的先后次序来挑选作业，先进入系统的作业将优先被挑选进入内存，创建用户进程，分配所需资源，然后移入就绪队列。</li>
</ul>
<h3 id="SJF-最短时间优先算法"><a href="#SJF-最短时间优先算法" class="headerlink" title="SJF/最短时间优先算法"></a>SJF/最短时间优先算法</h3><ul>
<li><strong>非剥夺式调度算法</strong></li>
<li>SJF以进入系统作业所要求的CPU运行时间的长短为标准，总是选取预计计算时间最短的作业投入运行。</li>
</ul>
<h3 id="SRTF-最短剩余时间优先算法"><a href="#SRTF-最短剩余时间优先算法" class="headerlink" title="SRTF/最短剩余时间优先算法"></a>SRTF/最短剩余时间优先算法</h3><ul>
<li><strong>剥夺式调度算法</strong></li>
<li>假设当前某进程/线程正在运行，如果有新进程/线程移入就绪队列，若它所需要的CPU运行时间比当前运行进程/线程所需要的剩余CPU时间还短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行。</li>
</ul>
<h3 id="HRRF-最高响应比优先算法"><a href="#HRRF-最高响应比优先算法" class="headerlink" title="HRRF/最高响应比优先算法"></a>HRRF/最高响应比优先算法</h3><ul>
<li><strong>非剥夺式调度算法</strong></li>
<li>响应比 = 作业周转时间 / 作业处理时间 = 1 + 作业等待时间 / 作业处理时间</li>
<li>作业处理时间由用户给出，是一个常量；作业等待时间开始于时间点0，随着作业在后备队列中等待时间的增加而变长，每当调度作业运行时，计算后备作业队列中每个作业的响应比作为其优先级，选择响应比最高者投入运行。</li>
</ul>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><ul>
<li>系统可预先规定为<strong>非剥夺式或剥夺式</strong></li>
<li>优先级调度算法根据确定的优先级来选取进程/线程，总是选择就绪队列中优先级最高者投入运行。</li>
</ul>
<h3 id="RR-轮转调度算法-时间片调度"><a href="#RR-轮转调度算法-时间片调度" class="headerlink" title="RR/轮转调度算法/时间片调度"></a>RR/轮转调度算法/时间片调度</h3><ul>
<li><strong>剥夺式调度算法</strong></li>
<li>调度程序每次把CPU分配给就绪队列首进程/线程使用规定的时间间隔，称为时间片，通常为10ms~200ms，就绪队列中的每个进程/线程轮流地运行一个时间片，当时间片耗尽时就强迫当前运行进程/线程让出处理器，转而排列到就绪队列尾部，等候下一轮调度。</li>
</ul>
<h3 id="MLFQ-多级反馈队列调度算法"><a href="#MLFQ-多级反馈队列调度算法" class="headerlink" title="MLFQ/多级反馈队列调度算法"></a>MLFQ/多级反馈队列调度算法</h3><ul>
<li><strong>剥夺式调度算法</strong></li>
<li>由系统建立多个就绪队列，每个队列对应于一个优先级，第一个队列的优先级最高，第二个队列的优先级次之，其后的优先级逐个降低。</li>
<li>较高优先级队列的进程/线程分配给较短时间片，较低优先级队列的进程/线程分配给较长时间片，最后一个队列进程/线程按FCFS算法进行调度。</li>
</ul>
<hr>
<h2 id="8-多级反馈调度算法有何性能特点？"><a href="#8-多级反馈调度算法有何性能特点？" class="headerlink" title="8. 多级反馈调度算法有何性能特点？"></a>8. 多级反馈调度算法有何性能特点？</h2><p>MLFQ调度算法具有较好的性能，能满足各类应用需要。</p>
<ul>
<li>对于分时交互性短作业，系统通常可在第一队列（最高优先级队列）规定的时间片内完成工作。</li>
<li>对于短的批处理作业，通常只需在第一队列和第二队列中各执行一个时间片就能完成工作，周转时间仍然很短。</li>
<li>对于长的批处理作业，它将依次在第一. 第二. 第三等各个队列中获得时间片运行。</li>
</ul>
<blockquote>
<p>假如一个长作业进入MLFQ，最终进入最低优先级队列后，有很多短作业进入队列，使其一直处于等待状态，则会产生饥饿。一种预防措施是对于低优先级队列中等待时间足够长得进程提升其优先级，从而让它获得运行机会。</p>
</blockquote>
<hr>
<h2 id="9-处理器调度分为哪三级？"><a href="#9-处理器调度分为哪三级？" class="headerlink" title="9. 处理器调度分为哪三级？"></a>9. 处理器调度分为哪三级？</h2><ul>
<li>高级调度：用于决定哪些满足资源需求的后备作业被选中进入内存去多道运行，FCFA. SJF. SRTF. HRRF. 优先级调度算法等是常用的作业调度算法；</li>
<li>中级调度：起均衡系统负载的作用，根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作；</li>
<li>低级调度：用于决定选择哪个进程/线程占有处理器运行，FCFS. RR. 优先数. MLFQ等是常用的进程/线程调度算法。</li>
</ul>
<blockquote>
<p>衡量调度算法优劣的因素包括响应时间. 周转时间. 资源利用率. 作业吞吐率和公平性等。</p>
</blockquote>
<hr>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><hr>
<h2 id="1-何为并发与并行？区别？"><a href="#1-何为并发与并行？区别？" class="headerlink" title="1. 何为并发与并行？区别？"></a>1. 何为并发与并行？区别？</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在操作系统中，在某一时间段有多个进程或线程同时存在。</p>
<p>并发的实质是一个处理器在几个进程之间的多路复用，并发是对有限的物理资源强制行使多用户共享，消除计算机部件之间的互等现象，以提高系统资源利用率。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>在操作系统中，在某一时间段有多个进程或线程同时执行</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>并行一定要多个进程或线程同时执行，而并发只要求能允许多个进程或线程同时存在，可以在单个CPU中交替执行，因此，并行是并发的一个子集。</p>
<hr>
<h2 id="2-何为并发过程的不确定性？为何会导致不确定性问题？请你举例说明？"><a href="#2-何为并发过程的不确定性？为何会导致不确定性问题？请你举例说明？" class="headerlink" title="2. 何为并发过程的不确定性？为何会导致不确定性问题？请你举例说明？"></a>2. 何为并发过程的不确定性？为何会导致不确定性问题？请你举例说明？</h2><p>并发过程的不确定性指每次执行结果都可能有所不同。导致不确定性的原因是程序外部的顺序特性消失，程序与计算不再一一对应。</p>
<p>例子：在煮咖啡时，若每次都按说明书上的顺序操作，那每次出来的咖啡都一样。但若采用并发，在某次准备往热水里放咖啡豆时，老板出来中断了你，然后喝了一口热水，之后将咖啡壶还给你，在进行相同操作后咖啡比以前浓。</p>
<hr>
<h2 id="3-何为进程？请用你自己的方式给进程下个定义？为何要引入进程？"><a href="#3-何为进程？请用你自己的方式给进程下个定义？为何要引入进程？" class="headerlink" title="3. 何为进程？请用你自己的方式给进程下个定义？为何要引入进程？"></a>3. 何为进程？请用你自己的方式给进程下个定义？为何要引入进程？</h2><ul>
<li>进程是操作系统中最重要和最基本的概念之一，<strong>引入进程是由系统资源的有限和系统内的并发性所决定的。</strong></li>
<li><strong>进程具有生命周期，</strong>由创建而产生，由调度而执行， 由撤销而消亡，<strong>操作系统的基本功能是进程的创建. 管理和撤销。</strong></li>
</ul>
<hr>
<h2 id="4-为何程序一当并发执行，结果就可能不再如传统顺序执行时的可再现性？"><a href="#4-为何程序一当并发执行，结果就可能不再如传统顺序执行时的可再现性？" class="headerlink" title="4. 为何程序一当并发执行，结果就可能不再如传统顺序执行时的可再现性？"></a>4. 为何程序一当并发执行，结果就可能不再如传统顺序执行时的可再现性？</h2><p>因为程序外部的顺序特性消失，程序与计算不再一一对应。每次执行都可能被中断或者环境变量被别的进程改变。</p>
<hr>
<h2 id="5-进程的特征有那些？如何理解这些特征？"><a href="#5-进程的特征有那些？如何理解这些特征？" class="headerlink" title="5. 进程的特征有那些？如何理解这些特征？"></a>5. 进程的特征有那些？如何理解这些特征？</h2><hr>
<h2 id="6-进程的状态有哪些？如何理解这些状态？"><a href="#6-进程的状态有哪些？如何理解这些状态？" class="headerlink" title="6. 进程的状态有哪些？如何理解这些状态？"></a>6. 进程的状态有哪些？如何理解这些状态？</h2><p><strong>进程的状态有运行态. 就绪态. 等待态</strong> </p>
<h3 id="运行态"><a href="#运行态" class="headerlink" title="运行态"></a>运行态</h3><p>进程占用处理器正在运行的状态</p>
<h3 id="就绪态"><a href="#就绪态" class="headerlink" title="就绪态"></a>就绪态</h3><p>进程具备运行条件，等待系统分配处理器以便运行的状态</p>
<h3 id="等待态"><a href="#等待态" class="headerlink" title="等待态"></a>等待态</h3><p>又称阻塞态或睡眠态，指进程不具备运行条件，正在等待某个事件完成的状态</p>
<hr>
<h2 id="7-请解释P95，118图2-4？"><a href="#7-请解释P95，118图2-4？" class="headerlink" title="7. 请解释P95，118图2-4？"></a>7. 请解释P95，118图2-4？</h2><hr>
<h2 id="8-进程有哪几部分构成？这些构成存于何处？PCB主要构成？PCB排队靠什么方式实现？"><a href="#8-进程有哪几部分构成？这些构成存于何处？PCB主要构成？PCB排队靠什么方式实现？" class="headerlink" title="8. 进程有哪几部分构成？这些构成存于何处？PCB主要构成？PCB排队靠什么方式实现？"></a>8. 进程有哪几部分构成？这些构成存于何处？PCB主要构成？PCB排队靠什么方式实现？</h2><p><strong>进程由进程控制块(PCB). 进程程序块. 进程核心栈和进程数据块组成</strong></p>
<h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><ol>
<li>进程控制块存于系统内存中的一个连续区域</li>
<li>进程程序块存于？？</li>
<li>进程核心栈存于？？</li>
<li>进程数据块存于？？</li>
</ol>
<h3 id="PCB主要构成"><a href="#PCB主要构成" class="headerlink" title="PCB主要构成"></a>PCB主要构成</h3><ol>
<li>标志信息</li>
<li>现场信息</li>
<li>控制信息</li>
</ol>
<h3 id="PCB排队"><a href="#PCB排队" class="headerlink" title="PCB排队"></a>PCB排队</h3><ol>
<li>链接方式</li>
<li>索引方式</li>
</ol>
<hr>
<h2 id="9-何为内核态与用户态？"><a href="#9-何为内核态与用户态？" class="headerlink" title="9. 何为内核态与用户态？"></a>9. 何为内核态与用户态？</h2><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>当处理器处于内核态时，这是操作系统管理程序运行时所在状态，可认为处理器正在运行可信系统软件，此时全部机器指令都被允许在处理器上执行，程序可访问所有内存单元和系统资源并具有改变处理器状态的能力。</p>
<h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>当处理器处于用户态时，它正在运行非可信应用程序此时无法执行特权指令，且访问权限仅限于当前处理器上执行程序所在的地址空间。</p>
<hr>
<h2 id="10-原语指啥？为何要引入原语？原语不可中断靠啥实现？"><a href="#10-原语指啥？为何要引入原语？原语不可中断靠啥实现？" class="headerlink" title="10. 原语指啥？为何要引入原语？原语不可中断靠啥实现？"></a>10. 原语指啥？为何要引入原语？原语不可中断靠啥实现？</h2><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>原语原语通常由若干条指令组成，用来实现某个特定的操作。通过一段不可分割的或不可中断的程序实现其功能。</p>
<h3 id="为何引入原语"><a href="#为何引入原语" class="headerlink" title="为何引入原语"></a>为何引入原语</h3><p>我们希望有若干指令的连续操作不会被打断</p>
<h3 id="原语不可中断靠啥实现"><a href="#原语不可中断靠啥实现" class="headerlink" title="原语不可中断靠啥实现"></a>原语不可中断靠啥实现</h3><p>通过关中断来实现</p>
<hr>
<h2 id="11-何为线程？现代OS为何要引入线程？与进程的区别？"><a href="#11-何为线程？现代OS为何要引入线程？与进程的区别？" class="headerlink" title="11. 何为线程？现代OS为何要引入线程？与进程的区别？"></a>11. 何为线程？现代OS为何要引入线程？与进程的区别？</h2><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程"></a>何为线程</h3><p>线程是进程中能并发执行的实体，是进程的组成部分，也是系统调度和分派的基本单位，运行在进程的上下文中,并使用进程的资源和环境。</p>
<h3 id="引入线程的理由"><a href="#引入线程的理由" class="headerlink" title="引入线程的理由"></a>引入线程的理由</h3><p>为了减少程序并发执行时所付出的时空开销，使得并发粒度更细. 并发性更好。</p>
<h3 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h3><ol>
<li>线程是进程的组成部分</li>
<li>线程切换较快</li>
<li>线程通信易于实现</li>
<li>线程并发程度比进程高</li>
</ol>
<hr>
<h2 id="12-单道与多道系统优缺点比较？"><a href="#12-单道与多道系统优缺点比较？" class="headerlink" title="12. 单道与多道系统优缺点比较？"></a>12. 单道与多道系统优缺点比较？</h2><p>多道程序能交替使用CPU，提高了CPU及其他系统资源的利用率，同时也提高了系统的效率。缺点是延长了作业的周转时间，用户不能进行直接干预，缺少交互性，不利于程序的开发与调试。</p>
<hr>
<h2 id="13-为何说中断是现代OS的一项必备技术？"><a href="#13-为何说中断是现代OS的一项必备技术？" class="headerlink" title="13. 为何说中断是现代OS的一项必备技术？"></a>13. 为何说中断是现代OS的一项必备技术？</h2><p>因为中断使在程序执行过程中，遇到急需处理的事件时，可以暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行。</p>
<hr>
<h2 id="14-请你给死锁下个定义？为何有死锁存在？"><a href="#14-请你给死锁下个定义？为何有死锁存在？" class="headerlink" title="14. 请你给死锁下个定义？为何有死锁存在？"></a>14. 请你给死锁下个定义？为何有死锁存在？</h2><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><p>操作系统中的死锁指：如果在一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件，则称一组进程或系统此时发生死锁。</p>
<h3 id="死锁存在原因"><a href="#死锁存在原因" class="headerlink" title="死锁存在原因"></a>死锁存在原因</h3><p>死锁产生不仅与系统拥有的资源数量有关，而且与资源分配策略，进程对资源的使用要求以及并发进程的推进顺序有关。</p>
<hr>
<h2 id="15-产生死锁的原因？"><a href="#15-产生死锁的原因？" class="headerlink" title="15. 产生死锁的原因？"></a>15. 产生死锁的原因？</h2><p>死锁产生不仅与系统拥有的资源数量有关，而且与资源分配策略，进程对资源的使用要求以及并发进程的推进顺序有关。</p>
<hr>
<h2 id="16-死锁产生的必要条件？举例说明？"><a href="#16-死锁产生的必要条件？举例说明？" class="headerlink" title="16. 死锁产生的必要条件？举例说明？"></a>16. 死锁产生的必要条件？举例说明？</h2><h3 id="1-互斥条件"><a href="#1-互斥条件" class="headerlink" title="1. 互斥条件"></a>1. 互斥条件</h3><p>进程互斥使用资源</p>
<p>例如，当只有一袋咖啡粉时，A拿了B就不能拿。</p>
<h3 id="2-部分分配条件"><a href="#2-部分分配条件" class="headerlink" title="2. 部分分配条件"></a>2. 部分分配条件</h3><p>申请新资源时不释放已占有资源</p>
<p>例如，当A拿到咖啡粉时，在拿到热水之前A不会将咖啡粉放出来，其他人不能使用咖啡粉。</p>
<h3 id="3-不剥夺条件"><a href="#3-不剥夺条件" class="headerlink" title="3. 不剥夺条件"></a>3. 不剥夺条件</h3><p>一个进程不能抢夺其他进程占有的资源</p>
<p>例如，在上面的例子中，B想要咖啡粉但它不能抢A的。</p>
<h3 id="4-环路条件"><a href="#4-环路条件" class="headerlink" title="4. 环路条件"></a>4. 环路条件</h3><p>存在一组进程循环等待资源</p>
<p>例如，在上述例子中，B恰好有热水，但他在拿到咖啡粉前不会放出热水给A使用，两者形成一个环路。</p>
<hr>
<h2 id="17-解释并分析其不同：预防死锁-避免死锁-检测死锁-解除死锁？"><a href="#17-解释并分析其不同：预防死锁-避免死锁-检测死锁-解除死锁？" class="headerlink" title="17. 解释并分析其不同：预防死锁. 避免死锁. 检测死锁. 解除死锁？"></a>17. 解释并分析其不同：预防死锁. 避免死锁. 检测死锁. 解除死锁？</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>在资源分配中破坏部分死锁必要条件。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果一个进程当前请求资源会导致死锁，系统将拒绝启动此进程；如果一个资源分配会导致系统下一步死锁，便拒绝本次分配。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>系统定时地运行一个“死锁检测”程序，判断系统内是否已出现死锁。</p>
<h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>检测到死锁发生以后，采用各种方法解除死锁状态以恢复到可运行状态。</p>
<h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>预防死锁是通过资源分配策略让死锁不可能发生，避免死锁是每次分配都进行安全性检测来避免进入死锁状态。而死锁检测和解除死锁是不防止或避免死锁，当检测到系统已经进入死锁状态后再处理。</p>
<hr>
<h2 id="18-预先分配策略是资源动态还是静态分配法？有何优缺点？"><a href="#18-预先分配策略是资源动态还是静态分配法？有何优缺点？" class="headerlink" title="18. 预先分配策略是资源动态还是静态分配法？有何优缺点？"></a>18. 预先分配策略是资源动态还是静态分配法？有何优缺点？</h2><p><strong>预先分配策略是资源静态分配法。</strong></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略实现简单</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>资源利用率低</p>
<hr>
<h2 id="19-动态与静态哪个对资源的利用率高？为什么？它们为何可以预防死锁？"><a href="#19-动态与静态哪个对资源的利用率高？为什么？它们为何可以预防死锁？" class="headerlink" title="19. 动态与静态哪个对资源的利用率高？为什么？它们为何可以预防死锁？"></a>19. 动态与静态哪个对资源的利用率高？为什么？它们为何可以预防死锁？</h2><p>动态资源利用率高，因为在每个进程占有的资源中，有些资源在运行后期使用，有些资源在例外情况下才被使用，可能会造成进程占有一些几乎用不到的资源，而使其他想使用这些资源的进程等待。</p>
<p>静态破坏了部分分配条件，而动态破坏环路条件。</p>
<hr>
<h2 id="20-何为安全状态？何为不安全状态？如何避免资源分配时进入不安全状态？"><a href="#20-何为安全状态？何为不安全状态？如何避免资源分配时进入不安全状态？" class="headerlink" title="20. 何为安全状态？何为不安全状态？如何避免资源分配时进入不安全状态？"></a>20. 何为安全状态？何为不安全状态？如何避免资源分配时进入不安全状态？</h2><p>安全状态就是存在一个安全序列使所有进程都能执行完并收回所有资源<br>。不安全状态是不存在这样的安全序列，即有可能进入死锁状态。在资源分配时，应该先对资源进行预分配，若该分配会使系统进入不安全状态，则拒绝此分配。</p>
<hr>
<h2 id="21-银行家算法的作用是什么？属于什么策略？"><a href="#21-银行家算法的作用是什么？属于什么策略？" class="headerlink" title="21. 银行家算法的作用是什么？属于什么策略？"></a>21. 银行家算法的作用是什么？属于什么策略？</h2><p>每一次分配之前都进行预分配和安全性评估来决定是否进行此分配</p>
<p>属于死锁避免策略。</p>
<hr>
<h2 id="22-银行家算法与安全检测算法的关系是什么？"><a href="#22-银行家算法与安全检测算法的关系是什么？" class="headerlink" title="22. 银行家算法与安全检测算法的关系是什么？"></a>22. 银行家算法与安全检测算法的关系是什么？</h2><p>安全检测算法是银行家算法的核心。</p>
<hr>
<h2 id="23-银行家算法的开销和对资源的利用率如何？"><a href="#23-银行家算法的开销和对资源的利用率如何？" class="headerlink" title="23. 银行家算法的开销和对资源的利用率如何？"></a>23. 银行家算法的开销和对资源的利用率如何？</h2><p>银行家算法的开销较高，因为要不断进行预分配和安全检测，资源利用率较高。</p>
<hr>
<h2 id="24-从死锁必要条件的角度解释资源预先分配法-资源暂时释放法-资源有序使用法-银行家算法等是如何预防或避免死锁发生的？"><a href="#24-从死锁必要条件的角度解释资源预先分配法-资源暂时释放法-资源有序使用法-银行家算法等是如何预防或避免死锁发生的？" class="headerlink" title="24. 从死锁必要条件的角度解释资源预先分配法. 资源暂时释放法. 资源有序使用法. 银行家算法等是如何预防或避免死锁发生的？"></a>24. 从死锁必要条件的角度解释资源预先分配法. 资源暂时释放法. 资源有序使用法. 银行家算法等是如何预防或避免死锁发生的？</h2><ol>
<li>预先分配法破坏了部分分配条件</li>
<li>资源暂时释放法破坏了不剥夺条件</li>
<li>资源有序使用法破坏了环路条件</li>
<li>银行家算法破环了环路条件</li>
</ol>
<hr>
<h2 id="25-简单叙述银行家算法的思想？"><a href="#25-简单叙述银行家算法的思想？" class="headerlink" title="25. 简单叙述银行家算法的思想？"></a>25. 简单叙述银行家算法的思想？</h2><ol>
<li>系统中的所有进程进入进程集合,</li>
<li>在安全状态下系统收到进程的资源请求后,先把资源试探性分配给它。</li>
<li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到剩余资源能满足最大需求量的进程,从而,保证这个进程运行完毕并归还全部资源。</li>
<li>把这个进程从集合中去掉, 系统的剩余资源更多了,反复执行上述步骤。</li>
<li>最后,检查进程集合,若为空表明本次申请可行,系统处于安全状态,可实施本次分配;否则,有进程执行不完，系统处于不安全状态,本次资源分配暂不实施,让申请进程等待。 </li>
</ol>
<hr>
<h2 id="26-何为资源分配图？"><a href="#26-何为资源分配图？" class="headerlink" title="26. 何为资源分配图？"></a>26. 何为资源分配图？</h2><ol>
<li>约定Pi→Rj为请求边，表示进程Pi申请资源类Rj中的一个资源得不到满足而处于等待Rj类资源的状态，该有向边从进程开始指到方框的边缘，表示进程Pi申请Rj类中的一个资源。</li>
<li>Rj→Pi为分配边，表示Rj类中的一个资源已被进程Pi占用，由于已把一个具体的资源分给了进程Pi，故该有向边从方框内的某个黑圆点出发指向进程。 </li>
</ol>
<hr>
<h2 id="27-何为死锁定理？"><a href="#27-何为死锁定理？" class="headerlink" title="27. 何为死锁定理？"></a>27. 何为死锁定理？</h2><ol>
<li>如果能在进程-资源分配图中消去此进程的所有请求边和分配边，成为孤立结点。经一系列简化，使所有进程成为孤立结点，则该图是可完全简化的；否则则称该图是不可完全简化的。</li>
<li>系统为死锁状态的充分条件是：当且仅当该状态的进程-资源分配图是不可完全简化的。该充分条件称为死锁定理。</li>
</ol>
<hr>
<h2 id="28-为何从资源分配图能否化简就能判断死锁的情形？图不能化简是否就说明机器存在死锁？"><a href="#28-为何从资源分配图能否化简就能判断死锁的情形？图不能化简是否就说明机器存在死锁？" class="headerlink" title="28. 为何从资源分配图能否化简就能判断死锁的情形？图不能化简是否就说明机器存在死锁？"></a>28. 为何从资源分配图能否化简就能判断死锁的情形？图不能化简是否就说明机器存在死锁？</h2><p>因为对资源分配图进行简化就相当于让一个进程获得足够的资源，在有限时间内执行完并释放资源。若不能完全化简，就意味着没有方法让进程全部执行完并收回资源，系统此时是死锁状态。</p>
<hr>
<h2 id="29-死锁检测算法的理论基础是什么？"><a href="#29-死锁检测算法的理论基础是什么？" class="headerlink" title="29. 死锁检测算法的理论基础是什么？"></a>29. 死锁检测算法的理论基础是什么？</h2><p>理论基础就是模拟资源分配图的化简过程，若不能完全化简，则进入死锁状态。</p>
<hr>
<h2 id="30-死锁如何解除？谈谈解除死锁的代价？"><a href="#30-死锁如何解除？谈谈解除死锁的代价？" class="headerlink" title="30. 死锁如何解除？谈谈解除死锁的代价？"></a>30. 死锁如何解除？谈谈解除死锁的代价？</h2><ol>
<li>结束所有进程的执行，重新启动操作系统。方法简单，但以前工作全部作废，损失很大。</li>
<li>撤销陷于死锁的所有进程，解除死锁继续运行。</li>
<li>逐个撤销陷于死锁的进程，回收其资源重新分派，直至死锁解除。</li>
<li>剥夺陷于死锁的进程占用的资源，但并不撤销它，直至死锁解除。可照撤销陷于死锁进程的条件来选择剥夺资源的进程</li>
<li>根据系统保存的检查点，让所有进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点. 回退及重启机制。</li>
<li>当检测到死锁时，如果存在某些未卷入死锁的进程，而随着这些进程执行到结束，有可能释放足够的资源来解除死锁。</li>
</ol>
<hr>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><hr>
<h2 id="1-立体（多级）存储体系指啥？为何要进行重定位？为何要进行地址映射"><a href="#1-立体（多级）存储体系指啥？为何要进行重定位？为何要进行地址映射" class="headerlink" title="1. 立体（多级）存储体系指啥？为何要进行重定位？为何要进行地址映射?"></a>1. 立体（多级）存储体系指啥？为何要进行重定位？为何要进行地址映射?</h2><p>立体（多级）存储体系指由寄存器. 高速缓存. 内存储器. 磁盘缓存. 固定磁盘. 可移动存储介质组成的一个存储器层次结构。</p>
<hr>
<h2 id="2-从单道到现代OS的虚拟内存管理这一发展线条？你来纵论一下？"><a href="#2-从单道到现代OS的虚拟内存管理这一发展线条？你来纵论一下？" class="headerlink" title="2. 从单道到现代OS的虚拟内存管理这一发展线条？你来纵论一下？"></a>2. 从单道到现代OS的虚拟内存管理这一发展线条？你来纵论一下？</h2><ol>
<li><pre><code class="hljs"> OS最初的单任务系统
</code></pre>
</li>
<li><pre><code class="hljs"> OS从单任务处理变为多任务并行处理
</code></pre>
</li>
<li><pre><code class="hljs"> MMU的开始使用
</code></pre>
</li>
<li><pre><code class="hljs"> 虚拟内存概念的出现
</code></pre>
</li>
</ol>
<hr>
<h2 id="3-你能否说清一种内存管理思想的原理及其地址映射过程（如：虚拟分页）？"><a href="#3-你能否说清一种内存管理思想的原理及其地址映射过程（如：虚拟分页）？" class="headerlink" title="3. 你能否说清一种内存管理思想的原理及其地址映射过程（如：虚拟分页）？"></a>3. 你能否说清一种内存管理思想的原理及其地址映射过程（如：虚拟分页）？</h2><h2 id="4-这些概念指啥：快表命中，页内零头，淘汰算法，抖动，碎片，紧凑，页故障率。"><a href="#4-这些概念指啥：快表命中，页内零头，淘汰算法，抖动，碎片，紧凑，页故障率。" class="headerlink" title="4. 这些概念指啥：快表命中，页内零头，淘汰算法，抖动，碎片，紧凑，页故障率。"></a>4. 这些概念指啥：快表命中，页内零头，淘汰算法，抖动，碎片，紧凑，页故障率。</h2><h3 id="快表命中"><a href="#快表命中" class="headerlink" title="快表命中"></a>快表命中</h3><p>当把页号交给快表后，它通过并行匹配同时对所有快表项进行比较，如果找到，则为快表命中。</p>
<h3 id="页内零头"><a href="#页内零头" class="headerlink" title="页内零头"></a>页内零头</h3><p>在页里面用户没有利用的部分。</p>
<h3 id="淘汰算法"><a href="#淘汰算法" class="headerlink" title="淘汰算法"></a>淘汰算法</h3><p>一个将快表或页表里将某一页淘汰掉并装入新的页的算法。</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>当存储管理方式采用页式存储时，缓存中的页需要可能被替换，下次要使用的页在这回却替换出去了，这样的现象就称为抖动。就会使得刚被替换出去的页又要重新加载。</p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>指操作系统在内存分配过程中，遗留下来的不能被利用到的内存区域。内存碎片导致部分内存被浪费，大量的内存碎片也会影响到系统的性能。</p>
<h3 id="紧凑"><a href="#紧凑" class="headerlink" title="紧凑"></a>紧凑</h3><p>将内存空闲区域集中在内存的一端拼接成一个较大的空闲分区，这种方法成为紧凑。</p>
<h3 id="页故障率"><a href="#页故障率" class="headerlink" title="页故障率"></a>页故障率</h3><p>发生缺页中断的比率。</p>
<hr>
<h2 id="5-内存地址映射过程为何要引入硬件寄存器？它与页表-段表-快表-进程表在数量设置上有何关系？内容呢，何时装入？"><a href="#5-内存地址映射过程为何要引入硬件寄存器？它与页表-段表-快表-进程表在数量设置上有何关系？内容呢，何时装入？" class="headerlink" title="5. 内存地址映射过程为何要引入硬件寄存器？它与页表. 段表. 快表. 进程表在数量设置上有何关系？内容呢，何时装入？"></a>5. 内存地址映射过程为何要引入硬件寄存器？它与页表. 段表. 快表. 进程表在数量设置上有何关系？内容呢，何时装入？</h2><p>引入硬件寄存器为了减少内存访问次数，提高访问效率。</p>
<p>页表只有一个，只有占用CPU的进程才占有它。</p>
<p>每个用户作业都有自己的段表。</p>
<p>快表只有一个，存最近访问的页表项。</p>
<p>进程表只有一个，存进程信息。</p>
<p>页表中存放的是页框的逻辑地址，在有新页框创建时装入。</p>
<p>段表中存放的是段的逻辑地址，在有新段创建时装入。</p>
<p>快表存的是常用页框的逻辑地址，在淘汰页框并更新快表时装入。</p>
<p>进程表存的是正在运行或就绪的进程信息，在创建进程时装入。</p>
<hr>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><hr>
<h2 id="1-设备驱动指什么？是否是OS的一部分？为何使用设备时需要安装驱动？不能事先集成入吗？"><a href="#1-设备驱动指什么？是否是OS的一部分？为何使用设备时需要安装驱动？不能事先集成入吗？" class="headerlink" title="1. 设备驱动指什么？是否是OS的一部分？为何使用设备时需要安装驱动？不能事先集成入吗？"></a>1. 设备驱动指什么？是否是OS的一部分？为何使用设备时需要安装驱动？不能事先集成入吗？</h2><ul>
<li><p>设备驱动程序包括与设备密切相关的所有代码，其任务是把用户提交的逻辑I/O请求转化为物理I/O操作的启动和执行；同时，监督设备是否正确执行，管理数据缓冲区，进行必要的纠错处理。</p>
</li>
<li><p>笼统地说，设备驱动程序的功能是从独立于设备的软件中接收并执行I/O请求。</p>
</li>
<li><p>设备驱动是OS的一部分</p>
</li>
<li><p>驱动负责沟通对应的硬件和操作系统，是两者之间的桥梁，不安装驱动的话操作系统则无法识别对应的硬件设备</p>
</li>
<li><p>可以事先集成设备驱动</p>
</li>
</ul>
<hr>
<h2 id="2-CPU如何实现对设备的控制？有哪些方式？各种方式的特点与原理？设备（如硬盘）要与内存传数，难道不和CPU冲突吗？"><a href="#2-CPU如何实现对设备的控制？有哪些方式？各种方式的特点与原理？设备（如硬盘）要与内存传数，难道不和CPU冲突吗？" class="headerlink" title="2. CPU如何实现对设备的控制？有哪些方式？各种方式的特点与原理？设备（如硬盘）要与内存传数，难道不和CPU冲突吗？"></a>2. CPU如何实现对设备的控制？有哪些方式？各种方式的特点与原理？设备（如硬盘）要与内存传数，难道不和CPU冲突吗？</h2><ul>
<li>按照I/O控制器功能的强弱以及它和CPU之间联系方式的不同，可以把设备控制方式分为<strong>轮询. 中断. DMA. 和通道</strong>4类。</li>
<li><strong>它们之间的差别在于CPU和设备并行工作的方式和程度不同。</strong></li>
</ul>
<h3 id="轮询方式"><a href="#轮询方式" class="headerlink" title="轮询方式"></a>轮询方式</h3><ul>
<li><p><strong>轮询方式又称程序直接控制方式，使用查询指令测试设备控制器的忙闲状态位，确定内存和设备是否能交换数据。</strong></p>
</li>
<li><p>轮询方式使用三条指令：</p>
</li>
<li><p><strong>查询指令：</strong>查询设备是否就绪；</p>
</li>
<li><p><strong>读写指令：</strong>当设备就绪时执行数据交换；</p>
</li>
<li><p><strong>转移指令：</strong>当设备未就绪时执行转移指令转向查询指令继续查询；</p>
</li>
</ul>
<h3 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h3><p>-中断方式要求CPU与设备控制器及设备之间存在中断请求线，设备控制器的状态寄存器有相应的中断允许位。</p>
<h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><ul>
<li>在DMA方式中，内存和设备之间有一条数据通路成块地传送数据，无须CPU干扰，实际数据传输操作由DMA直接完成。</li>
</ul>
<p><strong>DMA方式需以下设施：</strong></p>
<p>(1)<strong>内存地址寄存器：</strong>存放内存中需要交换数据的地址，DMA传送之前由程序送入首地址；DMA传送过程中，每次交换数据都把地址寄存器的内容加1。</p>
<p>(2)<strong>字计数器：</strong>记录传送数据的总字数，每次传送一个字就把字计数器减1。</p>
<p>(3)<strong>数据缓冲寄存器或数据缓冲区：</strong>暂存每次传送的数据。</p>
<p>(4)<strong>设备地址寄存器：</strong>存放I/O信息的地址，如磁盘的柱面号. 磁头号. 扇区号。</p>
<p>(5)<strong>中断机制和控制逻辑：</strong>用于向CPU提出I/O中断请求及保存CPU发来的I/O。</p>
<h3 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h3><ul>
<li>采用通道后的I/O操作过程：CPU在执行主程序时遇到I/O请求，它启动指定通道上选址的外围设备，一旦启动成功，通道开始控制外围设备进行操作。CPU就可执行其他任务并与通道并行工作，直到I/O操作完成。通道发出操作结束中断时，CPU才停止当前工作，转向处理I/O操作结束事件。</li>
</ul>
<hr>
<h2 id="3-OS的设备管理I-O子系统工作机制如何？请以缺页中断为例加以说明？"><a href="#3-OS的设备管理I-O子系统工作机制如何？请以缺页中断为例加以说明？" class="headerlink" title="3. OS的设备管理I/O子系统工作机制如何？请以缺页中断为例加以说明？"></a>3. OS的设备管理I/O子系统工作机制如何？请以缺页中断为例加以说明？</h2><h3 id="I-O操作执行步骤"><a href="#I-O操作执行步骤" class="headerlink" title="I/O操作执行步骤"></a>I/O操作执行步骤</h3><ol>
<li><p>进程对已打开文件的文件描述符执行读库函数；</p>
</li>
<li><p>独立设备I/O软件检查参数正确性。高速缓存中有要读的信息块，从缓冲区直接读到用户区，完成I/O请求；</p>
</li>
<li><p>若数据不在缓冲区，执行物理I/O，实现将设备逻辑名转换成物理名，检查对设备操作的权限，将I/O请求排队，阻塞进程且等待I/O完成；</p>
</li>
<li><p>内核启动设备驱动程序，分配存放读出块的缓冲区，准备接收数据，且向设备控制寄存器发启动命令，或建立DMA传输，启动I/O；</p>
</li>
<li><p>设备控制器操作设备，执行数据传输；</p>
</li>
<li><p>DMA控制器控制一块传输完成，硬件产生I/O结束中断；</p>
</li>
<li><p>CPU响应中断，转向磁盘中断处理程序。</p>
</li>
<li><p>当应用进程被再次调度执行时，从I/O系统调用的断点恢复执行。 </p>
</li>
</ol>
<h3 id="缺页异常处理过程"><a href="#缺页异常处理过程" class="headerlink" title="缺页异常处理过程"></a>缺页异常处理过程</h3><ul>
<li><strong>缺页异常是由于发现当前访问页面不在内存时由硬件所产生的一种特殊中断信号，是在指令执行期间产生并由系统处理的。</strong></li>
</ul>
<p>**缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤： **</p>
<ol>
<li><p>保护CPU现场 </p>
</li>
<li><p>分析中断原因 </p>
</li>
<li><p>转入缺页中断处理程序进行处理 </p>
</li>
<li><p>恢复CPU现场，继续执行 </p>
</li>
</ol>
<p>**但是缺页中断时由于所要访问的页面不存在内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在区别： **</p>
<ol>
<li><p>在指令执行期间产生和处理缺页中断信号 </p>
</li>
<li><p>一条指令在执行期间，可能产生多次缺页中断 </p>
</li>
<li><p>缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令</p>
</li>
</ol>
<p><strong>缺页异常的整个过程</strong></p>
<ol>
<li><p>首先硬件会陷入内核，在堆栈中保存<strong>程序计数器</strong>。<strong>大多数机器将当前指令的各种状态信息保存在CPU中特殊的寄存器中。</strong></p>
</li>
<li><p><strong>启动一个汇编代码例程保存通用寄存器及其它易失性信息，</strong>以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。（在页面换入换出的过程中可能会发生上下文换行，导致破坏当前程序计数器及通用寄存器中本进程的信息）</p>
</li>
<li><p>当操作系统发现是一个页面中断时，<strong>查找出来发生页面中断的虚拟页面</strong>（进程地址空间中的页面）。<strong>这个虚拟页面的信息通常会保存在一个硬件寄存器中，</strong>如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。</p>
</li>
<li><p><strong>检查虚拟地址的有效性及安全保护位。</strong>如果发生保护错误，则杀死该进程。</p>
</li>
<li><p><strong>操作系统查找一个空闲的页框(物理内存中的页面)，</strong>如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框。</p>
</li>
<li><p><strong>如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上，</strong>此时会引起一个<strong>写磁盘调用</strong>，发生上下文切换（在等待磁盘写的过程中让其它进程运行）。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）</p>
</li>
<li><p>页框干净后，<strong>操作系统根据虚拟地址对应磁盘上的位置，将保持在磁盘上的页面内容复制到“干净”的页框中，</strong>此时会引起一个<strong>读磁盘调用</strong>，发生上下文切换。</p>
</li>
<li><p><strong>当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。</strong>操作系统<strong>更新内存中的页表项，</strong>将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。</p>
</li>
<li><p><strong>恢复缺页中断发生前的状态，</strong>将程序指令器重新指向引起缺页中断的指令。</p>
</li>
<li><p><strong>调度引起页面中断的进程，</strong>操作系统返回汇编代码例程。</p>
</li>
<li><p><strong>汇编代码例程恢复现场，</strong>将之前保存在通用寄存器中的信息恢复。</p>
</li>
</ol>
<blockquote>
<p><strong>缺页中断的过程涉及了用户态和内核态之间的切换，虚拟地址和物理之间的转换（这个转换过程需要使用MMU和TLB），同时涉及了内核态到用户态的转换。</strong></p>
</blockquote>
<hr>
<h2 id="4-磁盘驱动这一举例中为何要提到“调度策略”？"><a href="#4-磁盘驱动这一举例中为何要提到“调度策略”？" class="headerlink" title="4. 磁盘驱动这一举例中为何要提到“调度策略”？"></a>4. 磁盘驱动这一举例中为何要提到“调度策略”？</h2><ul>
<li><p><strong>对于系统性能产生重要影响的是磁盘I/O，</strong>为了提高磁盘I/O性能，广为使用的有两种方法：<strong>磁盘驱动调度和磁盘缓冲区。</strong></p>
</li>
<li><p>不同的调度策略算法对于磁盘驱动调度的性能影响很大，从而对磁盘I/O性能再到系统整体性能表现影响也很大。</p>
</li>
</ul>
<hr>
<h2 id="5-为何要用到缓冲？DMA中的缓冲区作用为何？"><a href="#5-为何要用到缓冲？DMA中的缓冲区作用为何？" class="headerlink" title="5. 为何要用到缓冲？DMA中的缓冲区作用为何？"></a>5. 为何要用到缓冲？DMA中的缓冲区作用为何？</h2><h3 id="为何要用到缓冲？"><a href="#为何要用到缓冲？" class="headerlink" title="为何要用到缓冲？"></a>为何要用到缓冲？</h3><ul>
<li><p>数据离开设备之后通常不能直接送达目的地，所以必须通过<strong>缓冲区来消除填满速率和清空速率的影响。</strong></p>
</li>
<li><p>也就是说缓冲是为了解决高速设备和低速设备之间的速度不匹配问题。</p>
</li>
</ul>
<h3 id="DMA中的缓冲区作用为何？"><a href="#DMA中的缓冲区作用为何？" class="headerlink" title="DMA中的缓冲区作用为何？"></a>DMA中的缓冲区作用为何？</h3><ul>
<li><p>内存中用于与外设交互数据的一块区域被称作DMA缓冲区。</p>
</li>
<li><p>外设的设备读写速度与内存相比非常慢，因此需要使用缓冲区来减少等待时间，提高DMA的运行效率。</p>
</li>
</ul>
<hr>
<h2 id="6-何为虚拟设备？"><a href="#6-何为虚拟设备？" class="headerlink" title="6. 何为虚拟设备？"></a>6. 何为虚拟设备？</h2><ul>
<li><p>在<strong>一台共享设备上模拟若干台独享设备</strong>的操作，把独占型设备变成<strong>逻辑上的共享型设备</strong>，这种技术叫做<strong>虚拟设备技术。</strong></p>
</li>
<li><p>实现这种技术的软件和硬件被称为<strong>SPOOLING系统</strong>，使用SPOOLING技术所提供的设备就称为<strong>虚拟设备。</strong></p>
</li>
</ul>
<blockquote>
<p>实现虚拟设备的主要条件是：硬件上需要在磁盘上开辟输入井和输出井用做缓冲的存储区域。软件上需要预输入程序. 缓输出程序和井管理程序。</p>
</blockquote>
<hr>
<h2 id="7-OS中为何要引入逻辑设备？即在驱动中完成“逻辑设备—物理设备”对应？"><a href="#7-OS中为何要引入逻辑设备？即在驱动中完成“逻辑设备—物理设备”对应？" class="headerlink" title="7. OS中为何要引入逻辑设备？即在驱动中完成“逻辑设备—物理设备”对应？"></a>7. OS中为何要引入逻辑设备？即在驱动中完成“逻辑设备—物理设备”对应？</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>为了实现设备独立性而引入了逻辑设备和物理设备两概念。</strong>这使得应用程序独立于具体使用的物理设备。<br>这样的<strong>好处是提高了OS的可适应性和可扩展性</strong>,在应用程序中,使用逻辑设备名称来请求使用某类设备;而系统在实际执行时,还必须使用物理设备名称。</p>
<h3 id="设备独立性带来的好处"><a href="#设备独立性带来的好处" class="headerlink" title="设备独立性带来的好处"></a>设备独立性带来的好处</h3><ol>
<li><p>应用程序与具体物理设备无关，系统增减或变更设备时对源程序不必加以任何修改；</p>
</li>
<li><p>易于应对I/O设备故障，从而提高系统可靠性，增加设备分配的灵活性，能更有效地利用设备资源，实现多道程序设计；</p>
</li>
</ol>
<hr>
<h2 id="8-IDE是什么？串口与并口指什么？举例？PCI呢？"><a href="#8-IDE是什么？串口与并口指什么？举例？PCI呢？" class="headerlink" title="8. IDE是什么？串口与并口指什么？举例？PCI呢？"></a>8. IDE是什么？串口与并口指什么？举例？PCI呢？</h2><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul>
<li><p>平常所说的IDE接口，也称之为ATA接口。ATA的英文拼写为“Advanced Technology Attachment”，含义是“高级技术附加装置”。</p>
</li>
<li><p>早期的IDE接口有两种传输模式，一个是PIO（Programming I/O）模式，另一个是DMA（Direct Memory Access）。</p>
</li>
</ul>
<h3 id="串口与并口"><a href="#串口与并口" class="headerlink" title="串口与并口"></a>串口与并口</h3><ul>
<li><p><strong>串行接口简称串口</strong>，也称串行通信接口或串行通讯接口<strong>（通常指COM接口）</strong>，是采用串行通信方式的扩展接口。串行接口 (Serial Interface) 是<strong>指数据一位一位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信</strong>（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。</p>
</li>
<li><p><strong>并行接口，指采用并行传输方式来传输数据的接口标准。</strong>一个并行接口的接口特性可以从两个方面加以描述：1. 以并行方式传输的数据通道的宽度，也称接口传输的位数；2. 用于协调并行数据传输的额外接口控制线或称交互信号的特性。 数据的宽度可以从1～128位或者更宽</p>
</li>
<li><p><strong>SCSI和IDE都是并行接口。</strong></p>
</li>
<li><p>串口形容一下就是：一条车道，而并口就是有多个车道同一时刻能传送多位（一个字节）数据。但是并不是并口快。由于多位通道之间的互相干扰，传输时速度就受到了限制。而且当传输出错时，要同时重新传多个位的数据。而串口没有干扰，传输出错后重发一位就可以了，所以要比并口快。</p>
</li>
</ul>
<h3 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h3><ul>
<li>PCI是Peripheral Component Interconnect(外设部件互连标准)的缩写，它是目前个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。<strong>（可惜现在都变成了PCIe接口）</strong></li>
<li>PCI （Peripheral Component Interconnect）总线是一种高性能局部总线，是为了满足外设间以及外设与主机间高速数据传输而提出来的。在数字图形. 图像和语音处理，以及高速实时数据采集与处理等对数据传输率要求较高的应用中，采用PCI总线来进行数据传输，可以解决原有的标准总线数据传输率低带来的瓶颈问题。</li>
</ul>
<hr>
<h2 id="9-磁盘调度算法"><a href="#9-磁盘调度算法" class="headerlink" title="9. 磁盘调度算法"></a>9. 磁盘调度算法</h2><h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务/FCFS"></a>先来先服务/FCFS</h3><ul>
<li><p>First Come First Serve algorithm</p>
</li>
<li><p>顾名思义，先来的先服务，不考虑各I/O请求之间的相对次序和移动臂当前所处位置；</p>
</li>
<li><p>进程等待I/O请求的时间会很长，寻道性能较差；</p>
</li>
</ul>
<h3 id="最短查找时间优先算法-SSTF"><a href="#最短查找时间优先算法-SSTF" class="headerlink" title="最短查找时间优先算法/SSTF"></a>最短查找时间优先算法/SSTF</h3><ul>
<li><p>Shortest Seek Time First algorithm</p>
</li>
<li><p>SSTF考虑I/O请求之间的区别，<strong>总是先执行查找时间最短的请求，</strong>与FCS算法相比有较好的寻道性能。</p>
</li>
</ul>
<h3 id="扫描算法-SCAN"><a href="#扫描算法-SCAN" class="headerlink" title="扫描算法/SCAN"></a>扫描算法/SCAN</h3><ul>
<li><p>SCAN algorithm</p>
</li>
<li><p><strong>在SCAN中，移动臂每次沿一个方向移动，扫过所有柱面，遇到最近的I/O请求便进行处理，直至到达最后一个柱面后，再向相反的方向移动回来。</strong></p>
</li>
<li><p><strong>SCAN与电梯调度算法不同的是：即使当前移动方向暂时没有I/O请求，移动臂也需要扫描到头。</strong></p>
</li>
<li><p>扫描算法偏爱那些最接近里面或靠近外面的请求，对最近扫描所跨越区域的I/O请求的响应速度会较慢。</p>
</li>
</ul>
<h3 id="分步扫描算法-N-steps"><a href="#分步扫描算法-N-steps" class="headerlink" title="分步扫描算法/N-steps"></a>分步扫描算法/N-steps</h3><ul>
<li><p>N-steps scan algorithm</p>
</li>
<li><p><strong>将I/O请求分为长度为N的子队列，按FIFO算法依次处理每个子队列，而每个子队列采用扫描算法，处理完一个后再服务下一个子队列。</strong></p>
</li>
<li><p>在一段时间内进程重复请求访问同一柱面会垄断整个设备，造成磁盘臂停留在柱面上不动，<strong>称为“磁臂粘性”，</strong>使所有其他柱面的访问请求可能长时间得不到服务。</p>
</li>
<li><p>当N很大的时候 ，接近于扫描算法性能；当N=1的时候，接近于FIFO算法性能。</p>
</li>
</ul>
<h3 id="电梯调度算法-LOOK"><a href="#电梯调度算法-LOOK" class="headerlink" title="电梯调度算法/LOOK"></a>电梯调度算法/LOOK</h3><ul>
<li><p>elevator algorithm又称LOOK算法</p>
</li>
<li><p>SCAN算法的改进，无访问请求时，移动臂停止不动，有访问请求时，移动臂按电梯规律移动。</p>
</li>
<li><p><strong>LOOK不需要扫描到磁盘的尽头！</strong></p>
</li>
</ul>
<h3 id="循环扫描算法-Circular-scan"><a href="#循环扫描算法-Circular-scan" class="headerlink" title="循环扫描算法/Circular scan"></a>循环扫描算法/Circular scan</h3><ul>
<li><p>Circular scan algorithm</p>
</li>
<li><p><strong>移动臂总是从0号柱面至最大号柱面顺序扫描，然后直接返回0号柱面重复进行，归途中不再提供服务，</strong>构成一个循环，缩短处理新来请求的最大延迟。</p>
</li>
</ul>
<hr>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><hr>
<h2 id="1-文件如何分类？为何有这么多种分类？"><a href="#1-文件如何分类？为何有这么多种分类？" class="headerlink" title="1. 文件如何分类？为何有这么多种分类？"></a>1. 文件如何分类？为何有这么多种分类？</h2><p><strong>文件是由文件名字标识的一组信息的集合。可按各种方法进行分类：</strong></p>
<ul>
<li><p>按用途分类：</p>
</li>
<li><p>按保护级别分类：</p>
</li>
<li><p>按信息流向分类：</p>
</li>
<li><p>按存放时限分类：</p>
</li>
<li><p>按设备类型分类：</p>
</li>
<li><p>按文件的结构分类：</p>
</li>
</ul>
<p><strong>有多种分类的原因是文件本身的信息和属性多样，根据不同的用途. 权限. 存储方式等均可进行不同需求的划分。</strong></p>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liu_fei_er/article/details/80619625">https://blog.csdn.net/liu_fei_er/article/details/80619625</a></p>
</blockquote>
<hr>
<h2 id="2-系统实现按名存取文件主要依靠什么数据结构？"><a href="#2-系统实现按名存取文件主要依靠什么数据结构？" class="headerlink" title="2. 系统实现按名存取文件主要依靠什么数据结构？"></a>2. 系统实现按名存取文件主要依靠什么数据结构？</h2><ul>
<li><p>**文件控制块 (FCB)**是OS为每个文件建立的唯一数据结构，其中包含了全部文件属性，其目的是既便于用户的操作和使用，又便于操作系统对文件的管理和控制。</p>
</li>
<li><p><strong>一个文件由两部分组成 ：FCB 和文件体（文件信息）。</strong>有了 FCB 就可以实现文件的“按名存取”</p>
</li>
</ul>
<hr>
<h2 id="3-文件的组织有哪几种形式？文件和存储介质有什么关系？"><a href="#3-文件的组织有哪几种形式？文件和存储介质有什么关系？" class="headerlink" title="3. 文件的组织有哪几种形式？文件和存储介质有什么关系？"></a>3. 文件的组织有哪几种形式？文件和存储介质有什么关系？</h2><p>文件组织是指<strong>文件中信息的配置和构造方式</strong>，应该从<strong>文件的逻辑结构和组织</strong>以及<strong>文件的物理结构和组织</strong>两方面加以考虑。</p>
<h3 id="文件和存储介质的关系"><a href="#文件和存储介质的关系" class="headerlink" title="文件和存储介质的关系"></a>文件和存储介质的关系</h3><ul>
<li><p>文件的增删改查操作都与存储介质密切相关。</p>
</li>
<li><p>文件系统中的磁盘管理除管理文件空间外，还将文件的逻辑地址转换成磁盘的物理地址，即由逻辑块号找到柱面号. 磁头号和扇区号，设备与内存之间的数据传输操作由文件系统调用设备管理实现。</p>
</li>
</ul>
<hr>
<h2 id="4-文件的逻辑组织是什么概念？有哪些方式？"><a href="#4-文件的逻辑组织是什么概念？有哪些方式？" class="headerlink" title="4. 文件的逻辑组织是什么概念？有哪些方式？"></a>4. 文件的逻辑组织是什么概念？有哪些方式？</h2><p>文件的逻辑结构和组织指从用户观点出发，研究用户概念中抽象的信息组织方式，这是用户所能观察到的，可加以处理的数据集合。</p>
<p><strong>文件的逻辑结构分为两种形式：流式文件和记录式文件。</strong></p>
<h3 id="流式文件"><a href="#流式文件" class="headerlink" title="流式文件"></a>流式文件</h3><p><strong>流式文件是一种无结构的文件，</strong>文件内的数据不再组成记录，只是依次的一串信息集合，<strong>称为字节流文件，</strong>可以看成是只有一个记录的记录式文件。</p>
<blockquote>
<p>为了简化系统，大多数现代操作系统如Linux系统只提供流式文件。</p>
</blockquote>
<h3 id="记录式文件"><a href="#记录式文件" class="headerlink" title="记录式文件"></a>记录式文件</h3><p><strong>记录式文件是一种有结构的文件，</strong>它包含若干逻辑记录，逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位。</p>
<p>记录式文件中有两种常用的记录组织和使用方法：</p>
<ul>
<li><p><strong>记录式顺序文件：</strong>文件的记录顺序生成并被顺序访问。</p>
</li>
<li><p><strong>记录式索引顺序文件：</strong>这种文件使用索引表，表项包含记录键和索引指针，记录键由应用程序确定，而索引指针便指向相应记录。</p>
</li>
</ul>
<hr>
<h2 id="5-文件的物理组织是什么概念？有哪些方式？"><a href="#5-文件的物理组织是什么概念？有哪些方式？" class="headerlink" title="5. 文件的物理组织是什么概念？有哪些方式？"></a>5. 文件的物理组织是什么概念？有哪些方式？</h2><ul>
<li><p>文件的物理结构和组织是指逻辑文件在物理存储空间中的存放方法和组织关系，这时的文件看做物理文件，即相关物理块的集合。</p>
</li>
<li><p>文件的存储结构涉及：块的划分. 记录的排列. 索引的组织. 信息的搜索，其优劣直接影响文件系统的性能。</p>
</li>
<li><p><strong>有两类方法可以用来构造文件物理结构：计算法和指针法。</strong></p>
</li>
<li><p><strong>常用的文件物理结构和组织方法有：顺序文件. 连接文件. 索引文件. 直接文件。</strong></p>
</li>
</ul>
<hr>
<h2 id="6-文件目录与目录文件是指什么？"><a href="#6-文件目录与目录文件是指什么？" class="headerlink" title="6. 文件目录与目录文件是指什么？"></a>6. 文件目录与目录文件是指什么？</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><strong>为了加快文件查找速度，通常把FCB汇集和组织在一起形成文件目录，文件目录包含许多目录项，目录项有两种，分别用于描述子目录和描述文件。</strong></p>
<h3 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h3><ul>
<li><p>目录项的格式按统一标准定义，<strong>全部由目录项所构成的文件称为目录文件。</strong></p>
</li>
<li><p>目录文件保存在外存上，查找文件时调入内存工作区。</p>
</li>
<li><p>与普通文件不同，目录文件永远不会空，它至少包含两个目录项：<strong>当前目录“.”和父目录项“..”</strong>。</p>
</li>
</ul>
<hr>
<h2 id="7-文件的访问方式有哪些？请做说明？"><a href="#7-文件的访问方式有哪些？请做说明？" class="headerlink" title="7. 文件的访问方式有哪些？请做说明？"></a>7. 文件的访问方式有哪些？请做说明？</h2><p><strong>常用的文件访问方式有：顺序存取. 直接存取和索引存取</strong></p>
<h3 id="顺序存取"><a href="#顺序存取" class="headerlink" title="顺序存取"></a>顺序存取</h3><ul>
<li><p>无论是无结构字节流文件，还是有结构记录式文件，存取操作都在上次操作的基础上进行。系统设置读写两个位置指针，指向要读出或写入的字节位置或记录位置。</p>
</li>
<li><p><strong>顺序存取主要用于磁带文件，但也适用于磁盘上的顺序文件。</strong></p>
</li>
</ul>
<h3 id="直接存取"><a href="#直接存取" class="headerlink" title="直接存取"></a>直接存取</h3><ul>
<li><p>又称随机存取，可以非顺序地从文件中的任何位置存取文件内容。</p>
</li>
<li><p><strong>直接存取方法适合于要求快速地以任意次序直接读写某条记录的应用，</strong>如订机票；<strong>它也通常用于磁盘文件。</strong></p>
</li>
</ul>
<h3 id="索引存取"><a href="#索引存取" class="headerlink" title="索引存取"></a>索引存取</h3><ul>
<li>这是基于索引文件的存取方法，由于文件中的记录不按位置而是按其记录名或记录键来编址，所以用户提供记录名或记录键后，先按名搜索，再查找所需要的记录。</li>
</ul>
<hr>
<h2 id="8-文件控制块（FCB）的作用？"><a href="#8-文件控制块（FCB）的作用？" class="headerlink" title="8. 文件控制块（FCB）的作用？"></a>8. 文件控制块（FCB）的作用？</h2><ul>
<li><p>文件控制块（File Control Block，FCB）是操作系统为每个文件建立的唯一数据结构，<strong>其中包含了全部文件属性，其目的是为方便操作系统对文件的管理. 控制和存取。</strong></p>
</li>
<li><p>有了FCB就可以方便地实现文件的按名存取。</p>
</li>
<li><p>每当创建一个文件时，系统就要为其建立一个FCB，用来记录文件的属性信息；每当存取文件时，先找到其FCB，再找到文件信息盘块号. 首块物理位置或索引表就能存取文件信息。</p>
</li>
</ul>
<hr>
<h2 id="9-目录结构的概念与分级情形？"><a href="#9-目录结构的概念与分级情形？" class="headerlink" title="9. 目录结构的概念与分级情形？"></a>9. 目录结构的概念与分级情形？</h2><ul>
<li><p>最简单的文件目录时一级目录结构，所有FCB排列在一张线性表中，<strong>其缺点是文件重名和文件共享问题难以解决。</strong></p>
</li>
<li><p><strong>实际上，所有文件系统都支持多级层次结构，根目录是唯一的，每一级目录可以是下一级目录的说明，也可以是文件的说明，从而形成树状目录结构。</strong></p>
</li>
</ul>
<p><strong>树状多级目录结构有许多优点：</strong></p>
<ol>
<li><p>可以较好地反映现实世界中具有层次关系的数据集合，确切地反映系统内部文件的分支结构；</p>
</li>
<li><p>不同文件可以重名，只要它们不位于同一末端子目录中即可；</p>
</li>
<li><p>易于规定不同层次或子目录中文件的不同存取权限，便于文件的保护. 保密和共享等；</p>
</li>
<li><p>有利于系统的维护和查找。</p>
</li>
</ol>
<hr>
<h2 id="10-删除文件主要删除哪些内容？为何删除的文件可以被恢复？你认为删除文件应该删除哪些内容？请从安全性与性能两方面来解释各自的影响？"><a href="#10-删除文件主要删除哪些内容？为何删除的文件可以被恢复？你认为删除文件应该删除哪些内容？请从安全性与性能两方面来解释各自的影响？" class="headerlink" title="10. 删除文件主要删除哪些内容？为何删除的文件可以被恢复？你认为删除文件应该删除哪些内容？请从安全性与性能两方面来解释各自的影响？"></a>10. 删除文件主要删除哪些内容？为何删除的文件可以被恢复？你认为删除文件应该删除哪些内容？请从安全性与性能两方面来解释各自的影响？</h2><ul>
<li><p>一个文件由两部分组成：FCB和文件体（文件信息）；</p>
</li>
<li><p>删除文件主要删除其FCB信息，文件信息还保存在磁盘中，因此只要找到磁盘中对应位置的数据就可以恢复被删除的文件。</p>
</li>
<li><p>从性能方面来说，只删除FCB是优秀的选择，这样速度更快，系统开销更小；</p>
</li>
<li><p>从安全性方面来说，删除文件时应将文件信息也一并删除；</p>
</li>
</ul>
<hr>
<h2 id="11-就你所了解的文件物理组织中，哪些是你认为不错的组织方式？"><a href="#11-就你所了解的文件物理组织中，哪些是你认为不错的组织方式？" class="headerlink" title="11. 就你所了解的文件物理组织中，哪些是你认为不错的组织方式？"></a>11. 就你所了解的文件物理组织中，哪些是你认为不错的组织方式？</h2><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><ul>
<li><p><strong>将文件中逻辑上连续的信息存放到存储介质的相邻物理块上形成顺序结构，叫做顺序文件，又称连续文件。</strong></p>
</li>
<li><p><strong>顺序文件的优点</strong>是顺序存取记录时速度快，在批处理文件. 系统文件中用得很多。</p>
</li>
<li><p><strong>顺序文件的缺点</strong>是建立文件之前需要预先确定文件长度，以便分配存储空间；修改. 插入和添加文件记录有一定的难度；对于变长记录的处理很困难；对磁盘作连续分配会造成空闲块的浪费。</p>
</li>
</ul>
<h3 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h3><ul>
<li><p><strong>连接结构的特点是使用连接字，又称指针，来表示文件中各条记录之间的关系。</strong></p>
</li>
<li><p>连接结构克服了顺序结构不适应于增. 删. 改的缺点，对某些操作会带来好处，但在其他方面又会失去一些性能。</p>
</li>
<li><p>使用连接文件很容易把数据记录组织起来，但是查找某条记录需遍历链接结构，效率很低。</p>
</li>
</ul>
<h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><ul>
<li><p><strong>索引结构式实现非连续存储的另一种方法，适用于数据记录保存在磁盘上的文件。</strong></p>
</li>
<li><p>索引结构是连接结构的一种扩展，除了具备连接文件的优点外，记录可以散列存储，具有直接读写任意记录的能力，便于信息的增. 删. 改。</p>
</li>
<li><p>缺点是索引表的空间开销和查找时间的开销大，大型文件的索引表的信息量甚至可能远远超过文件记录本身的信息量。</p>
</li>
</ul>
<h3 id="直接文件"><a href="#直接文件" class="headerlink" title="直接文件"></a>直接文件</h3><ul>
<li><p><strong>在直接存取存储设备上，利用哈希法将记录的关键字与其地址之间建立某种对应关系，以便实现快速存取的文件叫做直接文件. 散列文件或哈希文件。</strong></p>
</li>
<li><p>这种存储结构用在不能采用顺序组织方法. 次序较乱. 又需在极短时间内进行存取的场合，对于实时处理文件. 目录文件. 存储管理的页表查找. 编译程序变量名表等的管理十分有效。</p>
</li>
</ul>
<hr>
<h2 id="12-请你把文件操作与上一章的设备管理结合起来，叙述文件读写的整个过程？"><a href="#12-请你把文件操作与上一章的设备管理结合起来，叙述文件读写的整个过程？" class="headerlink" title="12. 请你把文件操作与上一章的设备管理结合起来，叙述文件读写的整个过程？"></a>12. 请你把文件操作与上一章的设备管理结合起来，叙述文件读写的整个过程？</h2><p>心累，不说。</p>
<hr>
<h2 id="13-定期紧缩磁盘空间会导致什么好处？"><a href="#13-定期紧缩磁盘空间会导致什么好处？" class="headerlink" title="13. 定期紧缩磁盘空间会导致什么好处？"></a>13. 定期紧缩磁盘空间会导致什么好处？</h2><ul>
<li><p><strong>因为文件被分散保存到整个磁盘的不同地方，而不是连续地保存在磁盘连续的簇中形成的。</strong>硬盘在使用一段时间后，由于反复写入和删除文件，<strong>磁盘中的空闲扇区会分散到整个磁盘中不连续的物理位置上，</strong>从而使文件不能存在连续的扇区里。这样，再读写文件时就需要到不同的地方去读取，<strong>增加了磁头的来回移动，降低了磁盘的访问速度。</strong></p>
</li>
<li><p><strong>定期紧缩磁盘空间可以使原本分散的文件碎片被重新整理到一起，减少磁盘在读取的时候的磁头移动，增高磁盘的读写效率。</strong></p>
</li>
</ul>
<hr>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/others/" class="category-chain-item">others</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/operatingsystem/">#operatingsystem</a>
      
        <a href="/tags/stu/">#stu</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/20190117-compiling/" title="编译原理复习提纲">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">编译原理复习提纲</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/20181112-win-install-tomcat/" title="Windows上Apache Tomcat的安装配置">
                        <span class="hidden-mobile">Windows上Apache Tomcat的安装配置</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-copyright"></i> <a href="https://tinychen.com/" target="_blank" rel="nofollow noopener"><span>2017~2022 By TinyChen </span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Hexo-Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      粤ICP备18140640号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?7a96963a1145ac7fde1442d739a11ffd";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript('https://www.google-analytics.com/analytics.js', function() {
          window.ga = window.ga || function() { (ga.q = ga.q || []).push(arguments) };
          ga.l = +new Date;
          ga('create', 'UA-166769908-1', 'auto');
          ga('send', 'pageview');
        });
      }
    </script>
  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
